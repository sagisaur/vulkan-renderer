#version 460
#extension GL_EXT_shader_16bit_storage: require
#extension GL_EXT_shader_8bit_storage: require
#extension GL_EXT_mesh_shader: require
#extension GL_EXT_shader_explicit_arithmetic_types: require

#include "mesh.h"

layout(local_size_x = 32) in; // workgroup/block size, i.e 32 threads per meshlet here
layout(max_vertices = 64, max_primitives = 126) out; // 64 vertices, 126 triangles max
layout(triangles) out;

layout(set = 0, binding = 0) uniform UniformBufferObject {
    mat4 model;
    mat4 view;
    mat4 proj;
} ubo;

layout(set = 1, binding = 0) readonly buffer Vertices {
    Vertex vertices[];
};
layout(set = 1, binding = 1) readonly buffer Meshlets {
    Meshlet meshlets[];
};

layout(location = 0) out vec3 fragNormal[];
layout(location = 1) out vec2 fragTexCoords[];

// just to try to visualize meshlets
vec3 getMeshletColor(uint meshletIndex) {
    uint hash = meshletIndex;
    hash = hash * 1664525u + 1013904223u;
    
    float r = float((hash >> 0) & 0xFF) / 255.0;
    hash = hash * 1664525u + 1013904223u;
    float g = float((hash >> 0) & 0xFF) / 255.0;
    hash = hash * 1664525u + 1013904223u;
    float b = float((hash >> 0) & 0xFF) / 255.0;
    
    return vec3(r * 0.7 + 0.3, g * 0.7 + 0.3, b * 0.7 + 0.3);
}

void main() {
    uint tid = gl_LocalInvocationID.x; // 0-32
    uint meshletIndex = gl_WorkGroupID.x;

    uint numTrianglesPerMeshlet = uint(meshlets[meshletIndex].triangleCount);
    uint numVerticesPerMeshlet = uint(meshlets[meshletIndex].vertexCount);

    // load all vertices that this meshlet needs
    for (uint i=tid; i<numVerticesPerMeshlet; i+=32) {
        uint globalVertexIndex = meshlets[meshletIndex].vertices[i];

        Vertex v = vertices[globalVertexIndex];
        vec3 inPosition = vec3(v.vx, v.vy, v.vz);
        vec3 inNormal = vec3(v.nx, v.ny, v.nz) / 255.0 * 2.0 - 1.0; // convert it from [0, 255] to [-1.0f, 1.0f]
        vec2 inTexCoords = vec2(v.tu, v.tv);

        // write the vertices that this workgroup is going to render
        gl_MeshVerticesEXT[i].gl_Position = ubo.proj * ubo.view * ubo.model * vec4(inPosition, 1.0);
        fragNormal[i] = getMeshletColor(meshletIndex);
        // fragNormal[i] = inNormal;
        fragTexCoords[i] = inTexCoords;
    }

    // load the triangles
    for (uint i=tid; i<numTrianglesPerMeshlet; i+=32) {
        uint8_t local0 = meshlets[meshletIndex].indices[i*3+0];
        uint8_t local1 = meshlets[meshletIndex].indices[i*3+1];
        uint8_t local2 = meshlets[meshletIndex].indices[i*3+2];
        // refer to vertices defined in gl_MeshVerticesEXT
        gl_PrimitiveTriangleIndicesEXT[i] = uvec3(local0, local1, local2);
    }
    // set the actual output counts
    if (tid==0) {
        SetMeshOutputsEXT(numVerticesPerMeshlet, numTrianglesPerMeshlet);
    }
}