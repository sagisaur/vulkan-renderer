#version 460
#extension GL_EXT_shader_16bit_storage: require
#extension GL_EXT_shader_8bit_storage: require
#extension GL_EXT_mesh_shader: require
#extension GL_EXT_shader_explicit_arithmetic_types: require

layout(local_size_x = 32) in; // workgroup/block size, i.e 32 threads per meshlet here
layout(max_vertices = 64, max_primitives = 126) out; // 64 vertices, 126 triangles max
layout(triangles) out;

layout(set = 0, binding = 0) uniform UniformBufferObject {
    mat4 model;
    mat4 view;
    mat4 proj;
} ubo;

struct Vertex {
	float16_t vx, vy, vz, vw; // vw is only for alignment
	uint8_t nx, ny, nz, nw; // nw is only for alignment
	float16_t tu, tv;
};
layout(set = 1, binding = 0) readonly buffer Vertices {
    Vertex vertices[];
};

struct Meshlet {
    // those point (index) to the actual global buffer, but they contain unique numbers
    uint vertices[64];
    // those point to the local vertex array above, so range is [0, 63] 
    uint8_t indices[126*3]; // up to 126 triangles
    uint8_t triangleCount; // max 126
    uint8_t vertexCount;  // max 64 unique vertices
};
layout(set = 1, binding = 1) readonly buffer Meshlets {
    Meshlet meshlets[];
};

layout(location = 0) out vec3 fragNormal[];
layout(location = 1) out vec2 fragTexCoords[];

// just to try to visualize meshlets
vec3 getMeshletColor(uint meshletIndex) {
    uint hash = meshletIndex;
    hash = hash * 1664525u + 1013904223u;
    
    float r = float((hash >> 0) & 0xFF) / 255.0;
    hash = hash * 1664525u + 1013904223u;
    float g = float((hash >> 0) & 0xFF) / 255.0;
    hash = hash * 1664525u + 1013904223u;
    float b = float((hash >> 0) & 0xFF) / 255.0;
    
    return vec3(r * 0.7 + 0.3, g * 0.7 + 0.3, b * 0.7 + 0.3);
}
vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}
vec3 getMeshletColorHSV(uint meshletIndex) {
    float hue = fract(float(meshletIndex) * 0.618033988749895); 
    return hsv2rgb(vec3(hue, 0.8, 0.9)); 
}

void main() {
    uint tid = gl_LocalInvocationID.x; // 0-32
    uint meshletIndex = gl_WorkGroupID.x;

    uint numTrianglesPerMeshlet = uint(meshlets[meshletIndex].triangleCount);
    uint numVerticesPerMeshlet = uint(meshlets[meshletIndex].vertexCount);

    // load all vertices that this meshlet needs
    for (uint i=tid; i<numVerticesPerMeshlet; i+=32) {
        uint globalVertexIndex = meshlets[meshletIndex].vertices[i];

        Vertex v = vertices[globalVertexIndex];
        vec3 inPosition = vec3(v.vx, v.vy, v.vz);
        vec3 inNormal = vec3(v.nx, v.ny, v.nz) / 255.0 * 2.0 - 1.0; // convert it from [0, 255] to [-1.0f, 1.0f]
        vec2 inTexCoords = vec2(v.tu, v.tv);

        // write the vertices that this workgroup is going to render
        gl_MeshVerticesEXT[i].gl_Position = ubo.proj * ubo.view * ubo.model * vec4(inPosition, 1.0);
        fragNormal[i] = getMeshletColor(meshletIndex);
        // fragNormal[i] = inNormal;
        fragTexCoords[i] = inTexCoords;
    }

    // load the triangles
    for (uint i=tid; i<numTrianglesPerMeshlet; i+=32) {
        uint8_t local0 = meshlets[meshletIndex].indices[i*3+0];
        uint8_t local1 = meshlets[meshletIndex].indices[i*3+1];
        uint8_t local2 = meshlets[meshletIndex].indices[i*3+2];
        // refer to vertices defined in gl_MeshVerticesEXT
        gl_PrimitiveTriangleIndicesEXT[i] = uvec3(local0, local1, local2);
    }
    // set the actual output counts
    if (tid==0) {
        SetMeshOutputsEXT(numVerticesPerMeshlet, numTrianglesPerMeshlet);
    }
}